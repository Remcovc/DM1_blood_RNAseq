---
title: "RvC_ReC_rMATS_SE"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(matrixStats)
library(grid)
library(corrplot)
```


## 

```{r}
#load and manage metadata
load(file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Analyses_rnaseq_recognition/results/mixed_effect_models/htseq_manual/samples.RDATA")

# this is the file with bamfiles from the rMATS run. Remove crap and turn into one string
MATS_names <- read.table(file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/rMATS/bam_paths.txt")
MATS_names <- strsplit(as.character(MATS_names),",")
MATS_names <- unlist(MATS_names)
MATS_names <- gsub("/mnt/xomics/remcovc/mapping_quantification_recognition/for_paper/bams/dedup/","",MATS_names)
MATS_names <- strsplit(as.character(MATS_names),"_")
MATS_names <- unlist(lapply(seq(1, length(MATS_names)), function(x) MATS_names[[x]][1]))


```

## Loading SE data

```{r}
#create a list of data for Splice Exclusion
SE.MATS.JC <- list()

#first load the raw rMATS output into the list
SE.MATS.JC[["raw_output"]] <- data.frame(read_delim("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/rMATS/SE.MATS.JC.txt", "\t", escape_double = FALSE, trim_ws = TRUE))

# count/PSI values are in comma-separated lists in the rMATS output. Those are extracted here per sample
for (parameter in c("IJC_SAMPLE_1","SJC_SAMPLE_1", "IncLevel1")){
  
  #split by sample and turn into numeric
SE.MATS.JC[[parameter]] <- do.call(rbind, strsplit(SE.MATS.JC[["raw_output"]][,parameter], ","))
SE.MATS.JC[[parameter]] <- matrix(as.numeric(SE.MATS.JC[[parameter]]), nrow = nrow(SE.MATS.JC[[parameter]]), ncol = ncol(SE.MATS.JC[[parameter]]))

# Create row (exon) names using the ID, gene symbol and exon length
rownames(SE.MATS.JC[[parameter]]) <- paste(SE.MATS.JC[["raw_output"]][["ID"]],
                                               SE.MATS.JC[["raw_output"]][["geneSymbol"]], SE.MATS.JC[["raw_output"]][["exonEnd"]]-SE.MATS.JC[["raw_output"]][["exonStart_0base"]], 
                                               "nt", 
                                               sep = "_")

#Remove files that are not in the samples table. Then, patientID+visit is copied from there
SE.MATS.JC[[parameter]] <- SE.MATS.JC[[parameter]][, as.numeric(MATS_names) %in% samples$Sequencing_sample_number]
colnames(SE.MATS.JC[[parameter]]) <- paste(samples$PatientID, samples$Visit, sep = "_")
}
```

## Filtering SE
```{r}
#lets check how many reads there are per exon
plot(rowMeans(SE.MATS.JC[["IJC_SAMPLE_1"]]))
plot(rowMeans(SE.MATS.JC[["SJC_SAMPLE_1"]]))

#for an arbitrary cutoff, select exons with at least 14 samples with more than 3 inclusion counts per exon. The number of exons passing this treshold is:
sum(rowSums(SE.MATS.JC[["IJC_SAMPLE_1"]] >= 3) >= 14)
# and 1 or more junction spanning read in 27 samples. The number of exons passing this treshold is
sum(rowSums(SE.MATS.JC[["SJC_SAMPLE_1"]] >= 1) >= 14)

# The number of exons passing this treshold is for either of above is used to filter
sum(mapply(any, rowSums(SE.MATS.JC[["IJC_SAMPLE_1"]] >= 3) >= 14 & rowSums(SE.MATS.JC[["SJC_SAMPLE_1"]] >= 1) >= 14))


#filter the exons by the above treshold
SE.MATS.JC[["filter"]] <- mapply(any, rowSums(SE.MATS.JC[["IJC_SAMPLE_1"]] >= 3) >= 14 & rowSums(SE.MATS.JC[["SJC_SAMPLE_1"]] >= 1) >= 14)
SE.MATS.JC_filtered <- lapply(c("IJC_SAMPLE_1","SJC_SAMPLE_1", "IncLevel1"), function(x) SE.MATS.JC[[x]][SE.MATS.JC[["filter"]],])
names(SE.MATS.JC_filtered) <- c("IJC_SAMPLE_1","SJC_SAMPLE_1", "IncLevel1")


save(SE.MATS.JC_filtered, file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/rMATS/rMATSSE.MATS.JC_filtered.RDATA")

```





## fitting data
```{r}
design <- model.matrix(~ as.numeric(samples[,"V2Mode"]))
colnames(design) <- c("intercept","V2Mode")

lm_fit <- list()
for (exon in rownames(SE.MATS.JC_filtered[["IncLevel1"]])){
lm_fit[[exon]] <- lm(as.numeric(SE.MATS.JC_filtered[["IncLevel1"]][exon,]) ~ c(design[,"V2Mode"]))
    }

lm_fit_coefficients <- lapply(names(lm_fit), function(x) summary(lm_fit[[x]])[["coefficients"]])
names(lm_fit_coefficients) <- names(lm_fit)

#split the coefficients per effect
lm_fit_values <- list()
lm_fit_values[["V2Mode_SE"]] <- do.call(rbind, lapply(names(lm_fit_coefficients), function(x) lm_fit_coefficients[[x]][2,]))
lm_fit_values[["V2Mode_SE"]] <- cbind(lm_fit_values[["V2Mode_SE"]], do.call(rbind, lm_fit_coefficients2 <- lapply(names(lm_fit), function(x) summary(lm_fit[[x]])[["r.squared"]])))

# create dataframe for each effect (only one here)
for (fit in names(lm_fit_values)){
lm_fit_values[[fit]] <- cbind(names(lm_fit_coefficients),
                                lm_fit_values[[fit]], 
                                p.adjust(lm_fit_values[[fit]][,"Pr(>|t|)"], method = "fdr"))
colnames(lm_fit_values[[fit]]) <-c("exon","Estimate","Std. Error","t_value","p.val","r2","FDR")
}

#turn into numeric
lm_fit_values[["V2Mode_SE"]] <- data.frame(lm_fit_values[["V2Mode_SE"]])
lm_fit_values[["V2Mode_SE"]][, !colnames(lm_fit_values[["V2Mode_SE"]]) %in% c("exon")] <- as.numeric(unlist(lm_fit_values[["V2Mode_SE"]][, !colnames(lm_fit_values[["V2Mode_SE"]]) %in% c("exon")]))

#histogram of pvalues
hist(lm_fit_values[["V2Mode_SE"]][,"p.val"], breaks = 100, main = "histogram pvalues fit PSIs with CTG-repeat length")

#save files
save(lm_fit, file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/rMATS/lmfit_rMATS_CTGrepeat.RData")
save(lm_fit_values, file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/rMATS/lmfit_rMATS_CTGrepeat_values.RData")

```
