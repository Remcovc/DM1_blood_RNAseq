---
title: "Metadata"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(readr)
library(tidyverse)
```
## Load data

```{r}
#Load a table with hgcn symbols and corresponding Ensembl geneIDs, and remove duplicate entries
hgnc_symbol <- read.table("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Analyses_rnaseq_recognition/metadata/ENSG_geneSymbol.txt", sep =",", header=TRUE)
paste("this duplicate is removed:", hgnc_symbol[duplicated(hgnc_symbol$ensembl_gene_id),])
hgnc_symbol <- hgnc_symbol[!duplicated(hgnc_symbol$ensembl_gene_id),]
# for ENSEMBL IDs for which no hgnc symbol exist, paste ENSEMBL ID
hgnc_symbol$hgnc_symbol[hgnc_symbol$hgnc_symbol == ""] <- hgnc_symbol$ensembl_gene_id[hgnc_symbol$hgnc_symbol == ""]
write.table(hgnc_symbol, "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Analyses_rnaseq_recognition/metadata/ENSG_geneSymbol2.txt", sep =",")


# Load the Excel file from OPTIMISTIC with patient characteristics and outcome measures. This contains all metadata and outcome measures from OPTIMISTIC on a per-patient basis
metadata <- read_excel("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Outcome measures overview (V5)_corrected.xlsx")

load(file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Analyses_rnaseq_recognition/corrections_outcomes.RData")
```

## Prep and mangle

```{r}
# The original Excel file has two columns with PatientID. Here, one is removed and the other one is renamed
metadata$PatientID...164 <- NULL
names(metadata)[names(metadata) == "PatientID...1"] <- "PatientID"

# All patientIDs had a 'P' behind the ID, that is removed here. Also, spaces in the name of some columns are removed
metadata$PatientID <- gsub("P", "", metadata$PatientID)
colnames(metadata) <- gsub(" ", "", colnames(metadata))

#check correlation DM1Activ-C and V2Mode at baseline for all 250Â· patients in the cohort
cor.test(as.numeric(metadata$DM1ActivCV2), as.numeric(metadata$V2Mode), use = "complete.obs")
plot(as.numeric(metadata$DM1ActivCV2), as.numeric(metadata$V2Mode))

# Here, a key for the OPTIMISTIC RNA sample numbers to patientIDs and visit moment is loaded. This list is in the same order as the ReCognitION sequencing samples numbers, so the sequencing numbers (1-60) are added by a 1-60 number sequence
samples <- data.frame(cbind(seq(1,60,1),  
                            read_csv("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Analyses_rnaseq_recognition/metadata/sampleNumbers_visit.txt", col_names = FALSE)))
colnames(samples) <- c("Sequencing_sample_number","OPTIMISTIC_number","PatientID","Visit")

# All metadata is extracted per ReCognitION sequencing sample and sample names are added based on patientID and visit (V2 vs V4)
samples <- inner_join(samples, metadata, by = c("PatientID"="PatientID"), copy=TRUE)
rownames(samples) <- paste0(samples$PatientID, "_", samples$Visit)

# For four patients, not both sequencing runs were (succesfully) carried out, these are removed.
samples <- samples[-grep("A019|A052|A058|C037", samples$PatientID),]

# First, data is removed from timepoints that were not measured by RNA-seq
samples <- samples[, -grep ("V1|V3|V5", colnames(samples))]

#calculate Stroop score by dividing StroopIII by StroopII times
samples$StroopInterferenceV2 <- ((60 - as.numeric(samples$StroopCardIIIErrorsV2)/ 60)) / samples$StroopCardIIITimeV2 / ((60 - as.numeric(samples$StroopCardIIErrorsV2)/ 60)) / samples$StroopCardIITimeV2

samples$StroopInterferenceV4 <- ((60 - as.numeric(samples$StroopCardIIIErrorsV4)/ 60)) / samples$StroopCardIIITimeV4 / ((60 - as.numeric(samples$StroopCardIIErrorsV4)/ 60)) / samples$StroopCardIITimeV4

# calculate TMT ratio by dividing TMTB by TMTA times. This makes no sense but is the way it should be.
samples$TMTV2 <- as.numeric(samples$TMTBV2/samples$TMTAV2)
samples$TMTV4 <- as.numeric(samples$TMTBV4/samples$TMTAV4)

# Create a list of all available outcome measures (arbitrily based on V4) and remove entries which refer only to an outcome with a very low number of entries (AESI and CSI). Also, remove stroopcardI, II and III and TMT A and -B since these have been replaced by calculations based on these
outcome_measures <- gsub("V4", "", colnames(samples)[grep ("V4$",colnames(samples))])
outcome_measures <- outcome_measures[-grep ("Errors|AESI|CSI|StroopCard|TMTA|TMTB|MIRS|M5ENMO", outcome_measures)]

# Time point-related data that are not relevant for that sample (i.e. V4 data from a V2 sample) are set at NA to facilitate merging V2 and V4 columns, to prevent confusion and as a failsafe for incorrect code.
samples[grep ("V4$",rownames(samples)), grep ("V2$",colnames(samples))] <- NA
samples[grep ("V2$",rownames(samples)), grep ("V4$",colnames(samples))] <- NA

# Combine data from the V2 and V4 columns of each outcome measure to create a list element with the data from an outcome measure per sample. Then, add these to the samples table
outcome_values <- list()
for (outcome in c(outcome_measures)){
  outcome_values[[outcome]] <- dplyr::coalesce(samples[, paste(outcome, "V2", sep="")], 
                                               samples[, paste(outcome, "V4", sep="")])
}

# Create dataframe with all metadata
samples <- cbind(do.call(cbind, outcome_values), 
                 samples)

# Generate a list with strings of similar outcome measures, which can be queried to order the measures by type.
outcome_types <- list()
outcome_types[["Compound_scores"]]      <- c("DM1ActivC","MDHI","INQOLQolScore", "ASBQ","ICQ", "IMQ", "CISactivity")
outcome_types[["Physical"]]             <- c("SMWT", "MeanENMO" ,"PreBORG")
outcome_types[["Fatigue"]]              <- c("FDSS","CISFatigue", "JFCS")
outcome_types[["Cognitive"]]            <- c("TMT","StroopInterference")
outcome_types[["Pain_depr,_soc,_att."]] <- c("McGillPain","BDIFs", "SSLDScore", "SSLNScore", "SSLIScore","AEScScore","SES28")
#save(outcome_types, file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Analyses_rnaseq_recognition/outcome_types.RData")

# Select relevant metadata
samples <- samples[,colnames(samples) %in% c("PatientID", "Sequencing_sample_number", "Centre", "Sex", "AgeBaseline", "Visit","V2Mode", "CTGDiagnostic", "ePAL", unlist(outcome_types),"L5ENMO")]


#check correlation DM1Activ-C and V2Mode for the selected samples
#at baseline
cor.test(samples[grep("V2", rownames(samples)),"DM1ActivC"], as.numeric(samples[grep("V2", rownames(samples)),"V2Mode"]))
plot(samples[grep("V2", rownames(samples)),"DM1ActivC"], as.numeric(samples[grep("V2", rownames(samples)),"V2Mode"]))
#after CBT
cor.test(samples[grep("V4", rownames(samples)),"DM1ActivC"], as.numeric(samples[grep("V4", rownames(samples)),"V2Mode"]))
plot(samples[grep("V4", rownames(samples)),"DM1ActivC"], as.numeric(samples[grep("V4", rownames(samples)),"V2Mode"]))
```

## Calculation of scaled mean changes in outcome measures

```{r}

# Create list of change in outcome measures by looping over all outcome measures for all patients
dOutcomes <- list()
for (outcome in c(outcome_measures)){
  for (patient in c(unique(samples$PatientID))){
dOutcomes[[outcome]][[patient]] <- as.numeric(samples[paste0(patient,"_V4"), outcome]) - as.numeric(samples[paste0(patient,"_V2"), outcome])
  }  
  # Combine into one dataframe per outcome measure
dOutcomes[[outcome]] <- do.call(cbind, dOutcomes[[outcome]])
}

# Create dataframe of all outcome measures and patients
dOutcomes <- data.frame(do.call(rbind, dOutcomes))
rownames(dOutcomes) <- outcome_measures

# Correct outcomes for change in 'positive' direction by looping over all changes in outcome measures and multiply by 1 or -1
dOutcomes_corrected <- list()
for (outcome in rownames(dOutcomes)){
  dOutcomes_corrected[[outcome]] <-  as.numeric(corrections[outcome]*dOutcomes[outcome,])
}

#turn into dataframe and order
dOutcomes_corrected <- do.call(rbind, dOutcomes_corrected)
colnames(dOutcomes_corrected) <- colnames(dOutcomes)
dOutcomes_corrected <-  dOutcomes_corrected[,order(colnames(dOutcomes_corrected))]

# Scale by dividing all corrected changes in outcome measure by their standard deviation
scaled_outcomes <- t(scale(t(dOutcomes_corrected[!rownames(dOutcomes_corrected) == "L5ENMO",]), center = FALSE))

# Calculate the mean of all scaled corrected changes in all outcome measures per patient and write to dataframe with patientID
scaled_mean_outcomes <- data.frame(cbind(PatientID = colnames(scaled_outcomes), 
                                         scaled_mean_outcome = colMeans(scaled_outcomes, na.rm = TRUE)))

# Add mean scaled corrected outcomes per patient to samples table
samples <- inner_join(samples, scaled_mean_outcomes, by = c("PatientID"), copy = TRUE)

# Fix row names samples table 
rownames(samples) <- paste(samples$PatientID, samples$Visit, sep = "_")

# Save
write.csv(samples, 
          quote = FALSE,
          file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Figs_paper/TableS3_metadata.csv")
save(samples, file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Scripts_paper/samples.RDATA")
```



