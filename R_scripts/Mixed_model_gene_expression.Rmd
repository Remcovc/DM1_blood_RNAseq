---
title: "Mixed_effect_models_ReCognitION"
author: "Remco van Cruchten"
date: "10/14/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(limma)
library(tidyverse)
library(edgeR)
library(lmerTest)
```

## Loading metadata
```{r}
#Load a table with hgcn symbols and corresponding Ensembl geneIDs, and remove duplicate entries
hgnc_symbol <- read.table("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Analyses_rnaseq_recognition/metadata/ENSG_geneSymbol2.txt", sep =",", header=TRUE)
load(file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Analyses_rnaseq_recognition/outcome_types.RData")
load(file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/Scripts_paper/samples.RDATA")

```
## Loading data
```{r}

# Load each counts file in a list of files. The order is the same as the samples file above (sampleNumbers_visit.txt), sample 1 to sample 60
counts <- lapply(list.files(path = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/counts/", 
                            recursive = TRUE,
                            pattern = "counts.txt$", 
                            full.names = TRUE), 
                 read.table, 
                 sep = "\t", 
                 header = FALSE)

# bind the gene column of the first count table to the count columns of all tables to generate a table with gene names and counts
counts <- cbind(as.data.frame(counts[1])[1], 
                as.data.frame(
                  lapply(counts, 
                         function(x) bind_cols(x[2])))) 

# Set the row names of the count table to the gene names
row.names(counts) <- counts[,1]

# Remove the last five entries of the count tables (with e.g. no feature regions and ambiguous alignment) and the gene name row
counts <- counts[1:58735, 2:61]

# Retain only counts from samples that were retained in the samples overview 
counts <- counts[, samples$Sequencing_sample_number]

# set sample names as column name in counts table
colnames(counts) <- rownames(samples)


```

## Count filtering

Here, a dge object is made based on the count files and sample information. Counts are then filtered for lowly expressed genes, where a gene is removed if it is lowly expressed (<50 reads) in both the before and after CBT group (Visit=v2, before, or V4, after). 

```{r}
dge<- DGEList(counts = counts, 
              lib.size = colSums(counts),
              norm.factors = rep(1,ncol(counts)), 
              samples = rownames(samples),
              group = samples[,"Visit"], 
              genes = rownames(counts), 
              remove.zeros = FALSE)
dge <- dge[filterByExpr(dge, 
                        design = NULL, 
                        group = samples[,"Visit"], 
                        lib.size = NULL,
                        min.count = 50),
                        keep.lib.sizes = FALSE]
dge <- calcNormFactors(dge)

```

## Count normalization and fitting of mixed effect models 

Here, a linear mixed effect model is fitted for each gene using the lme4 wrapper lmerTest, which adds a p-value via Sattherthwaite's degrees of freedom method for t-testing. The outcome measure is taken along as a fixed effect, the patientID as a random effect. Messages are suppressed to prevent warning messages from singular fits. This information is added to the dataframe later.

Next, as measures of model quality, the r2, AIC and singularity of each fit are isolated/calculated. This is added to a dataframe with the values from all fits.


```{r}
model_values_all <- list()

for (outcome in c(unlist(outcome_types), "Visit", "L5ENMO")){
  print(paste("this is the analysis of", outcome))
  
# A design is made based on the outcome measure 
# Samples with missing data points are removed. 
# When the effect of CBT itself is tested via "Visit", the fitted value is given as a catagorical, otherwise as numeric
  
if (outcome == "Visit"){
design <- model.matrix(~samples[, outcome][!is.na(samples[, outcome])])}
  else{
    design <- model.matrix(~as.numeric(samples[, outcome][!is.na(samples[, outcome])]))}

colnames(design) <- c("(intercept)", outcome)
head(design)

# normalize the counts via Limma's Voom
v <- voom(dge[, !is.na(samples[,outcome])], design, plot=TRUE)
if (outcome == "Visit"){
  save(v, file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/fits_paper/v_visit.RDATA")}

# Providing a row name to the weight values
rownames(v$weights) <- rownames(v$E)

# Creating a list for the fitting, and perform fitting
lmer_fit <- list()

for (gene in rownames(v$E)){
  lmer_fit[[gene]] <- suppressMessages(lmerTest::lmer(v$E[gene,]  ~ design[, outcome] + (1|samples[,"PatientID"][!is.na(samples[, outcome])]), weights=v$weights[gene,]))
}
 

# Extract outcome values of fits, perform FDR and add quality parameters
lmer_fit_values <- cbind(
                         names(lmer_fit), 
                         do.call(rbind, (lapply(names(lmer_fit), function(x) summary(lmer_fit[[x]])[["coefficients"]][2,]))),
                         p.adjust(do.call(rbind, (lapply(names(lmer_fit), function(x) summary(lmer_fit[[x]])[["coefficients"]][2,"Pr(>|t|)"]))), method = "fdr"),
                         do.call(rbind, (lapply(names(lmer_fit), function(x) MuMIn::r.squaredGLMM(lmer_fit[[x]])))),
                         do.call(rbind, (lapply(names(lmer_fit), function(x) AIC(lmer_fit[[x]])))),
                         do.call(rbind, (lapply(names(lmer_fit), function(x) isSingular(lmer_fit[[x]])))))

# Add hgnc symbols
lmer_fit_values <- inner_join(hgnc_symbol,lmer_fit_values, by = c("ensembl_gene_id" = "V1"), copy=TRUE)

# Add sensible columns names
colnames(lmer_fit_values) <- c("ENSG", "hgnc_symbol", "Estimate", "Std.Error", "df", "t_value", "p.val", "FDR", "R2m", "R2c", "AIC", "isSingular")

# Save the fit and the outcome table
print("saving files")
save(lmer_fit, file = paste("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/Fits_paper/lmer_fit_",outcome,".RData", sep=""))
write.table(lmer_fit_values, file = paste("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/Fits_paper/lmer_fit_",outcome,"_values.csv", sep=""))

# Add values table to the list of all outcomes
model_values_all[[outcome]] <- lmer_fit_values
}
```

# Count normalization and fitting of linear models 
Here, Limma's lmfit is used to fit linear models for the CTG repeat length (=modal CTG repeat length at Visit 2, "V2Mode"). Duplicate measurements are annotated as 'blocks' according to the Limma manual

```{r}
for (outcome in c("V2Mode")){
  print(paste("this is the analysis of", outcome))

# making a design and normalize via Voom
design <- model.matrix(~as.numeric(samples[, outcome]))
colnames(design) <- c("(intercept)", outcome)
head(design)
v <- voom(dge, design, plot=FALSE, block = samples[, "PatientID"])

# fit
corfit <- duplicateCorrelation(v, design, block= samples[, "PatientID"])
lm_fit <-lmFit(v, design, correlation = corfit$consensus.correlation, weights = v$weights, block = samples[, "PatientID"])
lm_fit <- eBayes(lm_fit)
plotSA(lm_fit)
lm_fit_values <- topTable(lm_fit, coef= outcome, number=nrow(counts))

# Add hgnc symbols
lm_fit_values <- inner_join(hgnc_symbol,lm_fit_values, by = c("ensembl_gene_id" = "genes"), copy=TRUE)

# Add sensible columns names
colnames(lm_fit_values) <- c("ENSG", "hgnc_symbol", "Estimate", "AveExpr", "t_value", "p.val", "FDR", "B")

# Save the fit and the outcome table
print("saving files")
save(lm_fit, file = paste("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/Fits_paper/lm_fit_",outcome,".RData", sep=""))
write.table(lm_fit_values, file = paste("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/Fits_paper/lm_fit_",outcome,"_values.csv", sep=""))

# Add values table to the list of all outcomes
model_values_all[[outcome]] <- lm_fit_values
}

```

## Count normalization and fitting of mixed effect models with interaction component
```{r}
for (scaled_response in c("scaled_mean_outcome")){

# design with with interaction effect
design <- model.matrix(~samples[, "Visit"] * as.numeric(samples[, paste(scaled_response)]))
colnames(design) <- c("(intercept)", "CBT", scaled_response, paste0("int_CBT_", scaled_response))

head(design)

v <- voom(dge, design, plot=TRUE)
rownames(v$weights) <- rownames(v$E)

lmer_fit <- list()
for (gene in rownames(v$E)){
  lmer_fit[[gene]] <- suppressMessages(
    lmerTest::lmer(v$E[gene,]  ~ c(design[, "CBT"]) + design[, scaled_response] + design[, paste0("int_CBT_", scaled_response)] + (1|samples[, "PatientID"]), 
                   weights=v$weights[gene,])
    )
}

# extract model coefficients for each of the effects
lmer_fit_coefficients <- lapply(names(lmer_fit), function(x) summary(lmer_fit[[x]])[["coefficients"]])
names(lmer_fit_coefficients) <- names(lmer_fit)

lmer_fit_values <- list()
lmer_fit_values[["CBT"]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x) lmer_fit_coefficients[[x]][2,]))
lmer_fit_values[[scaled_response]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x) lmer_fit_coefficients[[x]][3,]))
lmer_fit_values[[paste0("int_CBT_", scaled_response)]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x) lmer_fit_coefficients[[x]][4,]))

for (fit in names(lmer_fit_values)){
lmer_fit_values[[fit]] <- cbind(names(lmer_fit_coefficients),
                                hgnc_symbol$hgnc_symbol[hgnc_symbol$ensembl_gene_id %in% names(lmer_fit_coefficients)],
                                lmer_fit_values[[fit]], 
                                p.adjust(lmer_fit_values[[fit]][, "Pr(>|t|)"], method = "fdr"))
colnames(lmer_fit_values[[fit]]) <-c("ENSG", "hgnc_symbol", "Estimate", "Std.Error", "df", "t_value", "p.val", "FDR")
}

lmer_fit_values[[paste0("int_CBT_", scaled_response)]] <- data.frame(lmer_fit_values[[paste0("int_CBT_", scaled_response)]])
lmer_fit_values[[paste0("int_CBT_", scaled_response)]][,3:8] <- as.numeric(unlist(lmer_fit_values[[paste0("int_CBT_", scaled_response)]][,3:8]))

print("saving files")
save(lmer_fit, file = paste("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/Fits_paper/lmer_fit_CBT_",scaled_response,"_allEff.RData", sep=""))
write.table(lmer_fit_values[[paste0("int_CBT_", scaled_response)]], file = paste("Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/Fits_paper/lmer_fit_CBT_",scaled_response,"_allEff_values.csv", sep=""))

model_values_all[[paste0("int_CBT_", scaled_response)]] <- lmer_fit_values[[paste0("int_CBT_", scaled_response)]]
}

```

## save overarching table

```{r}
# make sure all numeric values are numeric indeed
for (model in names(model_values_all)){
model_values_all[[model]][, !colnames(model_values_all[[model]]) %in% c("ENSG","hgnc_symbol", "isSingular")] <- as.numeric(unlist(model_values_all[[model]][, !colnames(model_values_all[[model]]) %in% c("ENSG","hgnc_symbol", "isSingular")]))
}

save(model_values_all, file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/Fits_paper/model_values_all.RDATA")

write.table(cbind(gene = hgnc_symbol$hgnc_symbol[hgnc_symbol[,"ensembl_gene_id"] %in% model_values_all[["Visit"]][,"ENSG"]], v$E), file = "Z:/Analysis_projects/RvC_recognition_rnaseq_diff_expr/for_paper_counts/Fits_paper/counts.csv", quote = FALSE )
```
