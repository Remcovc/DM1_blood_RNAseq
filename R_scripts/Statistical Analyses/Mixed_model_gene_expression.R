
## Script created on 29/6/2021, last update 1/9/2021
## Title: ReCognitION_Mixed_effect_models
## Author: Daniel van As

## This is an updated version of the original work generated by Remco van Cruchten
## Only the Mixed models are updated, no data-pre-processing steps

###############
## Libraries ##
###############

knitr::opts_chunk$set(echo = TRUE)
library(limma)
library(tidyverse)
library(edgeR)
library(lmerTest)


######################
## Loading datasets ##
######################

#Load a table with hgcn symbols and corresponding Ensembl geneIDs, and remove duplicate entries
hgnc_symbol <- read.table("ENSG_geneSymbol2.txt", sep =",", header=TRUE)
load(file = "outcome_types.RData")
load(file = "samples.RDATA")


# Load each counts file in a list of files. The order is the same as the samples file above (sampleNumbers_visit.txt), sample 1 to sample 54
counts <- lapply(list.files(path = "Z:/.../counts/", 
                            recursive = TRUE,
                            pattern = "counts.txt$", 
                            full.names = TRUE), 
                 read.table, 
                 sep = "\t", 
                 header = FALSE)

# bind the gene column of the first count table to the count columns of all tables to generate a table with gene names and counts
counts <- cbind(as.data.frame(counts[1])[1], 
                as.data.frame(
                  lapply(counts, 
                         function(x) bind_cols(x[2])))) 

# Set the row names of the count table to the gene names
row.names(counts) <- counts[,1]

# Remove the last five entries of the count tables (with e.g. no feature regions and ambiguous alignment) and the gene name row
counts <- counts[1:58735, 2:61]

# Retain only counts from samples that were retained in the samples overview 
counts <- counts[, samples$Sequencing_sample_number]

# set sample names as column name in counts table
colnames(counts) <- rownames(samples)


#####################
## Count filtering ##
#####################

# Here, a dge object is made based on the count files and sample information. 
# Counts are then filtered for lowly expressed genes, where a gene is removed 
# if it is lowly expressed (<50 reads) in both the before and after CBT group
# (Visit=v2, before, or V4, after). 


dge <- DGEList(counts = counts, 
              lib.size = colSums(counts),
              norm.factors = rep(1,ncol(counts)), 
              samples = rownames(samples),
              group = samples[,"Visit"], 
              genes = rownames(counts), 
              remove.zeros = FALSE)
dge <- dge[filterByExpr(dge, 
                        design = NULL, 
                        group = samples[,"Visit"], 
                        lib.size = NULL,
                        min.count = 50),
           keep.lib.sizes = FALSE]
dge <- calcNormFactors(dge)


################################
## Mixed linear effect models ##
################################

# Linear mixed effect models are fitted for each gene using the lm4 wrapper 
# lmerTest, which adds a p-value via Sattherwaite's degrees of freedom method
# for t-testing.
# singularfit warnings are suppressed, as they do not influence the coefficient
# nor the significance of the predictors of interest
# Patient as mixed term accounts for dependency of measures 
# Gene_weights are carried over from voom


###########################
## Gene - CBT effect fit ##
###########################

# Reflects the clinical response independent changes in gene expression after CBT
# Formula: gene_expr = CBT(before/after) + (1|Patient), weights

# design matrix
design <- model.matrix(~ samples[,"Visit"])
colnames(design) <- c("(Intercept", "CBT")

# gene weights data from voom
v <- voom(dge, design, plot=FALSE)
rownames(v$weights) <- rownames(v$E)
save(v, file = "v_visit.RDATA")

# fit mixed effects model for each gene
lmer_fit <- list()
for (gene in rownames(v$E)){
  lmer_fit[[gene]] <- suppressMessages(
    lmerTest::lmer(v$E[gene,] ~ design[,"CBT"] + 
                     (1|samples[,"PatientID"]), weights = v$weights[gene,]))
}

# extract regression coefficients and p-values
lmer_fit_coefficients <- lapply(names(lmer_fit), function(x) summary(lmer_fit[[x]])[["coefficients"]])
names(lmer_fit_coefficients) <- names(lmer_fit)

lmer_fit_values <- list()
lmer_fit_values[["CBT"]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x){lmer_fit_coefficients[[x]][2,]}))

# store relevant results per predictor in list, add gene names and FDR correction
for (fit in names(lmer_fit_values)){
  lmer_fit_values[[fit]] <- cbind(names(lmer_fit_coefficients),
                                  hgnc_symbol$hgnc_symbol[hgnc_symbol$ensembl_gene_id %in% names(lmer_fit_coefficients)],
                                  lmer_fit_values[[fit]], 
                                  p.adjust(lmer_fit_values[[fit]][, "Pr(>|t|)"], method = "fdr"))
  colnames(lmer_fit_values[[fit]]) <-c("ENSG", "hgnc_symbol", "Estimate", "Std.Error", "df", "t_value", "p.val", "FDR")
}

# convert certain rows to numeric
lmer_fit_values[["CBT"]] <- data.frame(lmer_fit_values[["CBT"]])
lmer_fit_values[["CBT"]][,3:8] <- as.numeric(unlist(lmer_fit_values[["CBT"]][,3:8]))

# temporarily store and save results
CBT_fit <- lmer_fit_values$CBT
write.table(lmer_fit_values[["CBT"]], file = paste("lmer_fit_CBT_values.csv", sep=""))
save(lmer_fit_values, file = "CBT_coef.RDATA")


#########################################
## Gene - Outcome measure associations ##
#########################################

# Formula: gene_expr = CBT(before/after) + outcome_measure + (1|Patient), weights
# Samples with missing datapoints are excluded
# Outcome_measure reflects the clinical score at V2 and V4
# Patient as mixed term accounts for dependency of measures 

outcome_coef <- list()
for (outcome in c(unlist(outcome_types))) {
  print(paste("Currently fitting", outcome))

  # Assure variable type to be numeric
  samples[,outcome] <- as.numeric(samples[,outcome])                            
  
  # design matrix  
  design <- model.matrix(~ samples[,"Visit"] + samples[,outcome])               # model.matrix removes rows with NA's by default
  colnames(design) <- c("(Intercept)", "CBT", outcome)
  
  # normalize gene counts and exclude samples with missing datapoints             
  v <- voom(dge[,!is.na(samples[,outcome])], design, plot=FALSE)               
  rownames(v$weights) <- rownames(v$E)
  
  # fit mixed effects model for each gene
  lmer_fit <- list()
  for (gene in rownames(v$E)){
    lmer_fit[[gene]] <- suppressMessages(
      lmerTest::lmer(v$E[gene,] ~ design[,"CBT"] + design[,outcome] + 
                       (1|samples[!is.na(samples[,outcome]),"PatientID"]), weights = v$weights[gene,]))
  }
  
  # extract regression coefficients and p-values
  lmer_fit_coefficients <- lapply(names(lmer_fit), function(x) summary(lmer_fit[[x]])[["coefficients"]])
  names(lmer_fit_coefficients) <- names(lmer_fit)
  
  lmer_fit_values <- list()
  lmer_fit_values[["CBT"]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x){lmer_fit_coefficients[[x]][2,]}))
  lmer_fit_values[[outcome]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x){lmer_fit_coefficients[[x]][3,]}))
  
  # store relevant results per predictor in list, add gene names and FDR correction
  for (fit in names(lmer_fit_values)){
    lmer_fit_values[[fit]] <- cbind(names(lmer_fit_coefficients),
                                    hgnc_symbol$hgnc_symbol[hgnc_symbol$ensembl_gene_id %in% names(lmer_fit_coefficients)],
                                    lmer_fit_values[[fit]], 
                                    p.adjust(lmer_fit_values[[fit]][, "Pr(>|t|)"], method = "fdr"))
    colnames(lmer_fit_values[[fit]]) <-c("ENSG", "hgnc_symbol", "Estimate", "Std.Error", "df", "t_value", "p.val", "FDR")
  }
  
  # convert certain rows to numeric
  lmer_fit_values[[outcome]] <- data.frame(lmer_fit_values[[outcome]])
  lmer_fit_values[[outcome]][,3:8] <- as.numeric(unlist(lmer_fit_values[[outcome]][,3:8]))
  
  # store relevant coefficient information & save outcome association information
  outcome_coef[[outcome]] <- lmer_fit_values
  write.table(lmer_fit_values[[outcome]], file = paste("lmer_fit_", outcome, "_values.csv", sep=""))
}

#store all outcome coefficient fits in a single RDATA file
save(outcome_coef, file = "outcome_coef.RDATA")


####################################
## Gene - CTG-repeat associations ##
####################################

# Formula: gene_expr = CBT(before/after) + V2Mode + (1|Patient), gene_weights
# CBT accounts for average improvement after intervention
# V2Mode reflects the association with CTG repeat length
# Patient as mixed term accounts for dependency of measures 
# Gene_weights are carried over from voom

# design matrix
design <- model.matrix(~ samples[,"Visit"] + as.numeric(samples[,"V2Mode"]))
colnames(design) <- c("(Intercept)", "CBT", "CTG")

# gene weights data from voom
v <- voom(dge, design, plot=TRUE)
rownames(v$weights) <- rownames(v$E)

# fit mixed effects model for each gene
lmer_fit <- list()
for (gene in rownames(v$E)){
  lmer_fit[[gene]] <- suppressMessages(
    lmerTest::lmer(v$E[gene,] ~ design[,"CBT"] + design[,"CTG"] + 
                     (1|samples[,"PatientID"]), weights = v$weights[gene,]))
}

# extract regression coefficients and p-values
lmer_fit_coefficients <- lapply(names(lmer_fit), function(x) summary(lmer_fit[[x]])[["coefficients"]])
names(lmer_fit_coefficients) <- names(lmer_fit)

lmer_fit_values <- list()
lmer_fit_values[["CBT"]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x){lmer_fit_coefficients[[x]][2,]}))
lmer_fit_values[["CTG"]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x){lmer_fit_coefficients[[x]][3,]}))

# store relevant results per predictor in list, add gene names and FDR correction
for (fit in names(lmer_fit_values)){
  lmer_fit_values[[fit]] <- cbind(names(lmer_fit_coefficients),
                                  hgnc_symbol$hgnc_symbol[hgnc_symbol$ensembl_gene_id %in% names(lmer_fit_coefficients)],
                                  lmer_fit_values[[fit]], 
                                  p.adjust(lmer_fit_values[[fit]][, "Pr(>|t|)"], method = "fdr"))
  colnames(lmer_fit_values[[fit]]) <-c("ENSG", "hgnc_symbol", "Estimate", "Std.Error", "df", "t_value", "p.val", "FDR")
}

# convert certain rows to numeric
lmer_fit_values[["CTG"]] <- data.frame(lmer_fit_values[["CTG"]])
lmer_fit_values[["CTG"]][,3:8] <- as.numeric(unlist(lmer_fit_values[["CTG"]][,3:8]))

# temporarily store and save results
CTG_fit_new <- lmer_fit_values$CTG
write.table(lmer_fit_values[["CTG"]], file = paste("lmer_fit_CTG_values.csv", sep=""))
save(lmer_fit_values, file = "CTG_coef.RDATA")
save(lmer_fit, file = "CTG_fits.RDATA")


##########################################
## Gene - Therapy response associations ##
##########################################

# Formula: gene_expr = CBT(before/after) + scaled_improvement + (1|Patient), gene_weights
# CBT accounts for changes independent of clinical improvement
# scaled_improvement reflects changes dependent on clinical improvement
# Patient as mixed term accounts for dependency of measures 

# design matrix
design <- model.matrix(~samples[, "Visit"] * as.numeric(samples[, "scaled_mean_outcome"]))
design <- design[,-3]
colnames(design) <- c("(Intercept)", "CBT", "scaled_response")

# gene weights data from voom
v <- voom(dge, design, plot=TRUE)
rownames(v$weights) <- rownames(v$E)

# fit mixed effects model for each gene
lmer_fit <- list()
for (gene in rownames(v$E)){
  lmer_fit[[gene]] <- suppressMessages(
  lmerTest::lmer(v$E[gene,] ~ design[,"CBT"] + design[,"scaled_response"] + 
                   (1|samples[,"PatientID"]), weights = v$weights[gene,]))
}

# extract regression coefficients and p-values
lmer_fit_coefficients <- lapply(names(lmer_fit), function(x) summary(lmer_fit[[x]])[["coefficients"]])
names(lmer_fit_coefficients) <- names(lmer_fit)

lmer_fit_values <- list()
lmer_fit_values[["CBT"]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x){lmer_fit_coefficients[[x]][2,]}))
lmer_fit_values[["scaled_response"]] <- do.call(rbind, lapply(names(lmer_fit_coefficients), function(x){lmer_fit_coefficients[[x]][3,]}))

# store relevant results per predictor in list, add gene names and FDR correction
for (fit in names(lmer_fit_values)){
  lmer_fit_values[[fit]] <- cbind(names(lmer_fit_coefficients),
                                  hgnc_symbol$hgnc_symbol[hgnc_symbol$ensembl_gene_id %in% names(lmer_fit_coefficients)],
                                  lmer_fit_values[[fit]], 
                                  p.adjust(lmer_fit_values[[fit]][, "Pr(>|t|)"], method = "fdr"))
  colnames(lmer_fit_values[[fit]]) <-c("ENSG", "hgnc_symbol", "Estimate", "Std.Error", "df", "t_value", "p.val", "FDR")
}

# convert certain rows to numeric
lmer_fit_values[["scaled_response"]] <- data.frame(lmer_fit_values[["scaled_response"]])
lmer_fit_values[["scaled_response"]][,3:8] <- as.numeric(unlist(lmer_fit_values[["scaled_response"]][,3:8]))

# temporarily store and save results
scaled_response_fit <- lmer_fit_values$scaled_response
write.table(lmer_fit_values[["scaled_response"]], file = paste("lmer_fit_scaled_response_values.csv", sep=""))
save(lmer_fit_values, file = "scaled_response_coef.RDATA")
save(lmer_fit, file = "scaled_response_fits.RDATA")




